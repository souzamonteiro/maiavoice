{"version":3,"file":"subtitle.cjs.production.min.js","sources":["../src/utils.ts","../src/formatTimestamp.ts","../src/map.ts","../src/Parser.ts","../src/parseTimestamp.ts","../src/parseTimestamps.ts","../src/Formatter.ts","../src/filter.ts","../src/parse.ts","../src/parseSync.ts","../src/resync.ts","../src/stringify.ts","../src/stringifySync.ts"],"sourcesContent":["import { Duplex, DuplexOptions } from 'stream'\n\nexport const padLeft = (value: number, length = 2): string =>\n  value.toString().padStart(length, '0')\n\nexport const createDuplex = (options: DuplexOptions) =>\n  new Duplex({\n    objectMode: true,\n    autoDestroy: false,\n    read() {},\n    ...options\n  })\n","import { padLeft } from './utils'\nimport { FormatOptions } from '.'\n\nexport function formatTimestamp(\n  timestamp: number,\n  options: FormatOptions = { format: 'SRT' }\n) {\n  const date = new Date(0, 0, 0, 0, 0, 0, timestamp)\n\n  const hours = date.getHours()\n  const minutes = date.getMinutes()\n  const seconds = date.getSeconds()\n  const ms = Math.floor(\n    timestamp - (hours * 3600000 + minutes * 60000 + seconds * 1000)\n  )\n\n  return `${padLeft(hours)}:${padLeft(minutes)}:${padLeft(seconds)}${\n    options.format === 'WebVTT' ? '.' : ','\n  }${padLeft(ms, 3)}`\n}\n","import { Transform } from 'stream'\nimport { Node } from '.'\n\nexport const map = (mapper: (node: Node, index: number) => any) => {\n  let index = 0\n\n  return new Transform({\n    objectMode: true,\n    autoDestroy: false,\n    transform(chunk: Node, _encoding, callback) {\n      callback(null, mapper(chunk, index++))\n    }\n  })\n}\n","import stripBom from 'strip-bom'\nimport { Node, RE_TIMESTAMP, parseTimestamps } from '.'\n\nexport type Pusher = (node: Node) => void\n\nexport interface ParseState {\n  expect: 'header' | 'id' | 'timestamp' | 'text' | 'vtt_comment'\n  row: number\n  hasContentStarted: boolean\n  isWebVTT: boolean\n  node: Partial<Node>\n  buffer: string[]\n}\n\nexport class Parser {\n  private push: Pusher\n  private state: ParseState\n\n  constructor({ push }: { push: Pusher }) {\n    this.push = push\n    this.state = {\n      expect: 'header',\n      row: 0,\n      hasContentStarted: false,\n      isWebVTT: false,\n      node: {},\n      buffer: []\n    }\n  }\n\n  private isIndex(line: string): boolean {\n    return /^\\d+$/.test(line.trim())\n  }\n\n  private isTimestamp(line: string): boolean {\n    return RE_TIMESTAMP.test(line)\n  }\n\n  private isVttComment(line: string): boolean {\n    return /^NOTE/.test(line)\n  }\n\n  private getError(expected: string, index: number, row: string): Error {\n    return new Error(\n      `expected ${expected} at row ${index + 1}, but received: \"${row}\"`\n    )\n  }\n\n  public parseLine(line: string): void {\n    const contents = this.state.row === 0 ? stripBom(line) : line\n\n    if (!this.state.hasContentStarted) {\n      if (contents.trim()) {\n        this.state.hasContentStarted = true\n      } else {\n        return\n      }\n    }\n\n    const parse = {\n      header: this.parseHeader,\n      id: this.parseId,\n      timestamp: this.parseTimestamp,\n      text: this.parseText,\n      vtt_comment: this.parseVttComment\n    }[this.state.expect]\n\n    parse.call(this, contents)\n\n    this.state.row++\n  }\n\n  public flush(): void {\n    if (this.state.buffer.length > 0) {\n      this.pushNode()\n    }\n  }\n\n  private parseHeader(line: string) {\n    if (!this.state.isWebVTT) {\n      this.state.isWebVTT = /^WEBVTT/.test(line)\n\n      if (this.state.isWebVTT) {\n        this.state.node.type = 'header'\n      } else {\n        this.parseId(line)\n        return\n      }\n    }\n\n    this.state.buffer.push(line)\n\n    if (!line) {\n      this.state.expect = 'id'\n      return\n    }\n  }\n\n  private parseId(line: string) {\n    this.state.expect = 'timestamp'\n\n    if (this.state.node.type === 'header') {\n      this.pushNode()\n    }\n\n    if (this.isIndex(line)) return\n\n    if (this.state.isWebVTT && this.isVttComment(line)) {\n      this.state.expect = 'vtt_comment'\n      return\n    }\n\n    this.parseTimestamp(line)\n  }\n\n  private parseVttComment(line: string) {\n    this.state.expect = 'vtt_comment'\n\n    if (line.trim() === '') {\n      this.state.expect = 'id'\n    }\n  }\n\n  private parseTimestamp(line: string) {\n    if (!this.isTimestamp(line)) {\n      throw this.getError('timestamp', this.state.row, line)\n    }\n\n    this.state.node = {\n      type: 'cue',\n      data: {\n        ...parseTimestamps(line),\n        text: ''\n      }\n    }\n\n    this.state.expect = 'text'\n  }\n\n  private parseText(line: string) {\n    if (this.state.buffer.length === 0) {\n      this.state.buffer.push(line)\n      return\n    }\n\n    if (this.isTimestamp(line)) {\n      const lastIndex = this.state.buffer.length - 1\n\n      if (this.isIndex(this.state.buffer[lastIndex])) {\n        this.state.buffer.pop()\n      }\n\n      this.pushNode()\n      this.parseTimestamp(line)\n      return\n    }\n\n    if (this.isVttComment(line)) {\n      this.pushNode()\n      this.parseVttComment(line)\n      return\n    }\n\n    this.state.buffer.push(line)\n  }\n\n  private pushNode(): void {\n    if (this.state.node.type === 'cue') {\n      while (true) {\n        const lastItem = this.state.buffer[this.state.buffer.length - 1]\n        if (['', '\\n'].includes(lastItem)) {\n          this.state.buffer.pop()\n        } else {\n          break\n        }\n      }\n\n      while (true) {\n        const firstItem = this.state.buffer[0]\n        if (['', '\\n'].includes(firstItem)) {\n          this.state.buffer.shift()\n        } else {\n          break\n        }\n      }\n\n      this.state.node.data!.text = this.state.buffer.join('\\n')\n    }\n\n    if (this.state.node.type === 'header') {\n      this.state.node.data = this.state.buffer.join('\\n').trim()\n    }\n\n    this.push(this.state.node as Node)\n\n    this.state.node = {}\n    this.state.buffer = []\n  }\n}\n","export function parseTimestamp(timestamp: string): number {\n  const match = timestamp.match(/^(?:(\\d{1,}):)?(\\d{2}):(\\d{2})[,.](\\d{3})$/)\n\n  if (!match) {\n    throw new Error('Invalid SRT or VTT time format: \"' + timestamp + '\"')\n  }\n\n  const hours = match[1] ? parseInt(match[1], 10) * 3600000 : 0\n  const minutes = parseInt(match[2], 10) * 60000\n  const seconds = parseInt(match[3], 10) * 1000\n  const milliseconds = parseInt(match[4], 10)\n\n  return hours + minutes + seconds + milliseconds\n}\n","import { parseTimestamp, Timestamp } from '.'\n\nexport const RE_TIMESTAMP = /^((?:\\d{1,}:)?\\d{2}:\\d{2}[,.]\\d{3}) --> ((?:\\d{1,}:)?\\d{2}:\\d{2}[,.]\\d{3})(?: (.*))?$/\n\nexport function parseTimestamps(value: string): Timestamp {\n  const match = RE_TIMESTAMP.exec(value)\n\n  if (!match) {\n    throw new Error('Invalid timestamp format')\n  }\n\n  const timestamp: Timestamp = {\n    start: parseTimestamp(match[1]),\n    end: parseTimestamp(match[2])\n  }\n\n  if (match[3]) {\n    timestamp.settings = match[3]\n  }\n\n  return timestamp\n}\n","import { FormatOptions, Node, Cue, formatTimestamp } from '.'\n\nexport class Formatter {\n  private options: FormatOptions\n  private isVTT: boolean\n  private hasReceivedHeader: boolean\n  private index: number\n\n  constructor(options: FormatOptions) {\n    this.options = options\n    this.hasReceivedHeader = false\n    this.isVTT = options.format === 'WebVTT'\n    this.index = 1\n  }\n\n  public format(node: Node): string {\n    let buffer = ''\n\n    if (node.type === 'header' && this.isVTT) {\n      this.hasReceivedHeader = true\n      buffer += `${node.data}\\n\\n`\n    }\n\n    if (node.type === 'cue') {\n      if (!this.hasReceivedHeader && this.isVTT) {\n        this.hasReceivedHeader = true\n        buffer += 'WEBVTT\\n\\n'\n      }\n\n      buffer += this.formatCue(node.data, this.index++, this.options)\n    }\n\n    return buffer\n  }\n\n  private formatCue(cue: Cue, index: number, options: FormatOptions) {\n    return [\n      `${index > 1 ? '\\n' : ''}${index}`,\n      `${formatTimestamp(cue.start, options)} --> ${formatTimestamp(\n        cue.end,\n        options\n      )}${\n        options.format === 'WebVTT' && cue.settings ? ' ' + cue.settings : ''\n      }`,\n      cue.text,\n      ''\n    ].join('\\n')\n  }\n}\n","import { Node } from '.'\nimport { Transform } from 'stream'\n\nexport const filter = (callback: (node: Node) => boolean) =>\n  new Transform({\n    objectMode: true,\n    autoDestroy: false,\n    transform: function transform(chunk, _encoding, next) {\n      callback(chunk) ? next(null, chunk) : next()\n    }\n  })\n","import multipipe from 'multipipe'\nimport split2 from 'split2'\nimport { createDuplex } from './utils'\nimport { Parser } from './Parser'\n\nexport const parse = () => {\n  const parser = new Parser({\n    push: node => outputStream.push(node)\n  })\n\n  const stream = createDuplex({\n    write(chunk, _encoding, next) {\n      try {\n        parser.parseLine(chunk.toString())\n      } catch (err) {\n        return next(err)\n      }\n\n      next()\n    }\n  })\n\n  const splitStream = split2()\n\n  splitStream.on('finish', () => {\n    parser.flush()\n    stream.push(null)\n  })\n\n  const outputStream = multipipe(splitStream, stream, {\n    objectMode: true\n  })\n\n  return outputStream\n}\n","import { Parser } from './Parser'\nimport { NodeList } from '.'\n\nexport const parseSync = (input: string): NodeList => {\n  const buffer: NodeList = []\n  const parser = new Parser({\n    push: node => buffer.push(node)\n  })\n\n  input\n    .replace(/\\r\\n/g, '\\n')\n    .split('\\n')\n    .forEach(line => parser.parseLine(line))\n\n  parser.flush()\n\n  return buffer\n}\n","import { map, Node } from '.'\n\nexport const resync = (time: number) =>\n  map((node: Node) => {\n    if (node.type === 'cue') {\n      return {\n        ...node,\n        data: {\n          ...node.data,\n          start: node.data.start + time,\n          end: node.data.end + time\n        }\n      }\n    }\n\n    return node\n  })\n","import { map, FormatOptions, Node } from '.'\nimport { Formatter } from './Formatter'\n\nexport const stringify = (options: FormatOptions) => {\n  const formatter = new Formatter(options)\n  return map((chunk: Node) => formatter.format(chunk))\n}\n","import { NodeList, FormatOptions } from '.'\nimport { Formatter } from './Formatter'\n\nexport const stringifySync = (\n  list: NodeList,\n  options: FormatOptions\n): string => {\n  const formatter = new Formatter(options)\n\n  return list.reduce((buffer, node) => {\n    return buffer + formatter.format(node)\n  }, '')\n}\n"],"names":["padLeft","value","length","toString","padStart","createDuplex","options","Duplex","objectMode","autoDestroy","read","formatTimestamp","timestamp","format","date","Date","hours","getHours","minutes","getMinutes","seconds","getSeconds","ms","Math","floor","map","mapper","index","Transform","transform","chunk","_encoding","callback","Parser","push","state","expect","row","hasContentStarted","isWebVTT","node","buffer","isIndex","line","test","trim","isTimestamp","RE_TIMESTAMP","isVttComment","getError","expected","Error","parseLine","contents","this","stripBom","header","parseHeader","id","parseId","parseTimestamp","text","parseText","vtt_comment","parseVttComment","call","flush","pushNode","type","data","parseTimestamps","pop","includes","shift","join","match","parseInt","exec","start","end","settings","Formatter","hasReceivedHeader","isVTT","formatCue","cue","next","parser","outputStream","stream","write","err","splitStream","split2","on","multipipe","input","replace","split","forEach","time","formatter","list","reduce"],"mappings":"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"}